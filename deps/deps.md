[![](https://img.shields.io/badge/go-home-gray.svg)](../README.md) 

Архитектура - это, в том числе и управление зависимостями.  

`a -> b -> c -> d`
Максимальная цепочка 4
Изменение d может затронуть a, b, c.

Инверсия зависимостей: вводим новую абстрактную сущность: 
`a -> b -> x <- c -> d`
 
Максимальная цепочка 3
Изменение d может затронуть только c.

Это же требование можно интерполировать на названия и пользовательскую документацию в любом её виде.
Если клиенту сказали, что мы используем технологию, то он от неё "зависит".

Плохо:
"Сохраняем объект в MySQL"
`Пользователь -> Сервис -> MySQL`
Клиент транзитивно зависит от MySQL

Лучше, но все равно плохо
"Сохраняем объект в базу данных"
`Пользователь -> Сервис -> база данных <- MySQL`
Клиент транзитивно зависит от базы данных, но уже не знает от какой.

Хорошо
"Сохраняем объект в хранилище"
`Пользователь -> Сервис -> хранилище <- база данных <- MySQL`
Клиент транзитивно зависит от абстрактного понятия хранилище.
А что там у нас база, файловая система или облако или все сразу,
это наше внутреннее решение. Когда мы его поменяем,
нам не придётся отправлять клиенту новую документацию.

Не используйте имена технологий в качестве имен ваших объектов. 
Все нужные классы, которые имеют в своем названии технологии, уже написаны за вас.
